include(`stdlib.cspir')

datatype USR = a.() | b.() | i.()
datatype KEY = ska.() | skb.() | pka.() | pkb.() | ski.() | pki.()
typevar NONCE
datatype MSG = \M -> nonce.NONCE | key.KEY | enc.KEY.M | user.USR | sq.(\L -> nil.() | cons.M.L)
datatype T = send.USR.USR.MSG | recv.USR.USR.MSG | running.USR.USR.NONCE | commit.USR.USR.NONCE

sk = \u : USR -> case u 
    of a -> \y : () -> ska.()
    of b -> \y : () -> skb.()
    of i -> \y : () -> ski.();

pk = \u : USR -> case u 
    of a -> \y : () -> pka.()
    of b -> \y : () -> pkb.()
    of i -> \y : () -> pki.();

dual = \k : KEY -> 
    case k
     of ska -> \y : () -> pka.()
     of pka -> \y : () -> ska.()
     of skb -> \y : () -> pkb.()
     of pkb -> \y : () -> skb.()
     of ski -> \y : () -> pki.()
     of pki -> \y : () -> ski.();

Initiator(self: USR) = |~| b: USR @ |~| na: NONCE @
        send!self!b!enc.(pk b, sq.(cons.(nonce.na, cons.(user.self, nil.()))))
    ->  |~| nb: NONCE @ 
        recv!self!b!enc.(pk self, sq.(cons.(nonce.na, cons.(nonce.nb, nil.()))))
    ->  commit!self!b!na
    ->  running!self!b!nb
    ->  send!self!b!enc.(pk b, nonce.nb)
    ->  SKIP

Responder(self: USR) = |~| a: USR @ |~| na: NONCE @
        recv!self!a!enc.(pk self, sq.(cons.(nonce.na, cons.(user.a, nil.()))))
    ->  running!self!a!na
    ->  |~| nb: NONCE @ (nb != na) & 
        send!self!a!enc.(pk a, sq.(cons.(nonce.na, cons.(nonce.nb, nil.()))))
    ->  recv!self!a!enc.(pk self, nonce.nb)
    ->  commit!self!a!nb
    ->  SKIP

Participant(u:USR) = Initiator(u) |~| Responder(u)

Network = send?from?to?m -> recv!to!from!m -> Network

Impl = let ua = a.() within
       let ub = b.() within
        (Participant(ua) [| {} |] Participant(ub)) 
        [| {send.*{USR.USR.MSG}, recv.*{USR.USR.MSG}} |] Network

assert {} |- Impl : Proc(T)

---------------------
-- Add an Intruder --
---------------------

instanciateList(MSG)
instanciateList(FACT)
instanciateList(Bool)

define(`substMSG', `nonce.NONCE | key.KEY | enc.KEY.$1 | user.USR | sq.(define(`loc', format(`L_subst_%d', ctr(`substMSG_Ctr')))\loc -> nil.() | cons.$1.loc undefine(`loc'))')
datatype FACT = List(MSG).MSG

------------------------
-- End List Functions --
------------------------

asMsgList = \m : MSG -> (cons.(m, nil.())) :: L_MSG;   


datatype TPL_L_FACT_MSG = L_FACT.MSG 
datatype TPL_L_MSG_MSG = L_MSG.MSG
datatype TPL_L_MSG_L_MSG = L_MSG.L_MSG

-- fold helper: Accumulates the sub explode sets and the original sq message sequence
unionSnd = \ls : nil.() | cons.Tuple(List(MSG), MSG).Tuple(List(MSG), List(MSG)) ->
    case ls
        of cons -> \ttpl : Tuple(List(MSG), MSG).Tuple(List(MSG), List(MSG)) ->
            let tpl = pr 1 ttpl within
            let accTpl = pr 2 ttpl within -- accumulator tuple for this fold
            let msg = pr 2 tpl within
            let explodeAcc = pr 1 tpl within -- accumulator produced by explode
            let sqls = pr 2 accTpl within 
            let acc = pr 1 accTpl within -- acummulator list
            let rsqls = (cons.(msg, sqls)) :: List(MSG) within -- collect the message reconstructing the original sq
            let racc = (union(MSG) acc explodeAcc) :: List(MSG) within
            (racc, rsqls) :: Tuple(List(MSG), List(MSG))
        of _ -> (nil.(), nil.());


expandCaseSplitMsg = \xs : List(MSG) -> \m: substMSG(Tuple(List(MSG),MSG)) -> 
    case m
        of enc -> \y : KEY.Tuple(List(MSG), MSG) -> 
            let k = pr 1 y within 
            let tpl = pr 2 y within
            let msg = pr 2 tpl within
            let acc = pr 1 tpl within
            let reconstr = (enc.(k, msg)) :: MSG within
            let nxs = (cons.(reconstr, xs)) :: List(MSG) within
            let bkp_tpl = (nxs, reconstr) :: Tuple(List(MSG), MSG) within
            if (elem(MSG) key.(dual k) xs) then (union(MSG) acc nxs, reconstr) else bkp_tpl
        of key -> \y : KEY -> (cons.(key.y, xs), key.y) :: Tuple(List(MSG), MSG)
        of user -> \y : USR -> (cons.(user.y, xs), user.y) :: Tuple(List(MSG), MSG)
        of nonce -> \y : NONCE -> (cons.(nonce.y, xs), nonce.y) :: Tuple(List(MSG), MSG)
        of sq -> \ys : AnonList(Tuple(List(MSG), MSG)) ->
            let reconstrTpl = (fold ys unionSnd) :: Tuple(List(MSG), List(MSG)) within
            let acc = pr 1 reconstrTpl within
            let ms = pr 2 reconstrTpl within (union(MSG) acc xs, sq.ms) :: Tuple(List(MSG), MSG);


rec expand :: List(MSG) -> List(MSG) = \xs : List(MSG) -> 
    let foldMsg = \m : MSG -> fold m (expandCaseSplitMsg xs) within
    let unionReducer = \m: MSG -> \a: List(MSG) -> let acc = pr 1 (foldMsg m) within union(MSG) acc a within
    let new_xs = ((listReduce(MSG, List(MSG)) xs) nil.()) unionReducer within
    if (diff(MSG) new_xs) xs == empty(MSG) then new_xs else expand new_xs;

instanciateTuple(Bool, MSG)
instanciateTuple(Bool, List(MSG))

deducibleCaseSplit = \m: MSG -> \db : List(MSG) -> let resultTpl = fold m (foldDeducibleCaseSplit db) within pr 1 resultTpl;

foldDeducibleCaseSplit = \db: List(MSG) -> \m : substMSG(Tuple(Bool, MSG)) ->
    case m
        of enc -> \y : KEY.Tuple(Bool, MSG) -> 
            let k = pr 1 y within
            let tpl = pr 2 y within
            let b = pr 1 tpl within
            let msg = pr 2 tpl within 
            ((elem(MSG) (enc.(k, msg)) db) or (elem(MSG) key.k db and b), enc.(k, msg)) :: Tuple(Bool, MSG)
        of nonce -> \n : NONCE -> ((elem(MSG) nonce.n db), nonce.n) :: Tuple(Bool, MSG)
        of user -> \u : USR -> ((elem(MSG) user.u db), user.u) :: Tuple(Bool, MSG)
        of key -> \k : KEY -> ((elem(MSG) key.k db), key.k) :: Tuple(Bool, MSG)
        of sq -> \ys: AnonList(Tuple(Bool, MSG)) -> 
        let redTpl = ((listReduce_(Tuple(Bool, MSG), Tuple(Bool, List(MSG))) ys) 
                        (true, (nil.())) ) 
                        (\x: Tuple(Bool, MSG) -> \y: Tuple(Bool, List(MSG)) -> ((pr 1 x) and (pr 1 y), (cons.(pr 2 x, pr 2 y)))) within 
        let checkResult = pr 1 redTpl within
        let msgList = pr 2 redTpl within 
        (checkResult, sq.msgList) :: Tuple(Bool, MSG);
 
isDeducible = \m: MSG -> \knwldg: List(MSG) -> let db = expand knwldg within deducibleCaseSplit m db;

initialKnowledge = (asList(key.(ski.()), key.(pki.()), key.(pkb.()), key.(pka.()))) :: List(MSG);

Spy(knowledge: List(MSG)) = SpyHear(knowledge) ||| SpySay(knowledge)  

SpySay(knowledge: List(MSG)) = (|~|m:MSG @ ((isDeducible m) knowledge) & SpyFake(m, knowledge)) 
                            |||
                               (SpySay(knowledge))

SpyFake(m: MSG, knwoledge: List(MSG)) = send?from?to!m -> Spy(knowledge) ||| recv?from?to!m -> Spy(knowledge)

SpyHear(knowledge: List(MSG)) = send?from?to?m -> let newKnowledge = cons.(m, knowledge) within Spy(newKnowledge)

HostileImpl = let ua = (a.()) :: USR within
              let ub = (b.()) :: USR within
        (Participant(ua) [| {} |] Participant(ub)) 
        [| {send.*{USR.USR.MSG}, recv.*{USR.USR.MSG}} |] let init = initialKnowledge :: List(MSG) within Spy(init)

assert {} |- HostileImpl : Proc(T)

RUN(a: USR, b: USR, n: NONCE) = running!a!b!n -> RUN(a, b, n) |~| commit!a!b!n -> RUN(a, b, n)

InjectiveAgreement(a: USR, b: USR, n: NONCE) = running!b!a!n -> RUN(a, b, n)

RunAllExceptRunningCommit(ca: USR, cb: USR, cn: NONCE) =    send?a?b?m -> RunAllExceptRunningCommit(ca, cb, cn) 
                                                        |~| recv?a?b?m -> RunAllExceptRunningCommit(ca, cb, cn)
                                                    |~|
                                                        (|~| n : NONCE @ if n == cn then STOP else 
                                                            |~| a : USR @ 
                                                            |~| b : USR @ if a == ca then STOP else
                                                                          if b == cb then STOP else running!a!b!n -> RunAllExceptRunningCommit(ca, cb, cn))
                                                    |~|
                                                        (|~| n : NONCE @ if n == cn then STOP else 
                                                            |~| a : USR @ 
                                                            |~| b : USR @ if a == ca then STOP else
                                                                          if b == cb then STOP else commit!a!b!n -> RunAllExceptRunningCommit(ca, cb, cn))

Spec = let ua = (a.()) :: USR within
       let ub = (b.()) :: USR within
       |~| n: NONCE @ InjectiveAgreement(ua, ub, n) ||| RunAllExceptRunningCommit(ua, ub, n)

assert {} |- Spec : Proc( T )