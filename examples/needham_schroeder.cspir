datatype USR = a.() | b.()
datatype KEY = ska.() | skb.() | pka.() | pkb.() | ski.() | pki.()
typevar NONCE
datatype MSG = \M -> nonce.NONCE | key.KEY | enc.KEY.M | user.USR | sq.(\L -> nil.() | cons.M.L)
datatype T = send.USR.USR.MSG | recv.USR.USR.MSG | running.USR.USR.NONCE | commit.USR.USR.NONCE

sk = \u : USR -> case u 
    of a -> \y : () -> ska.()
    of b -> \y : () -> skb.();

pk = \u : USR -> case u 
    of a -> \y : () -> pka.()
    of b -> \y : () -> pkb.();

dual = \k : KEY -> 
    case k
     of ska -> \y : () -> pka.()
     of pka -> \y : () -> ska.()
     of skb -> \y : () -> pkb.()
     of pkb -> \y : () -> skb.()
     of ski -> \y : () -> pki.()
     of pki -> \y : () -> ski.()

Initiator(self: USR) = |~| b: USR @ |~| na: NONCE @
        send!self!b!enc.(pk b, sq.(cons.(nonce.na, cons.(user.self, nil.()))))
    ->  |~| nb: NONCE @ 
        recv!self!b!enc.(pk self, sq.(cons.(nonce.na, cons.(nonce.nb, nil.()))))
    ->  commit!self!b!na
    ->  running!self!b!nb
    ->  send!self!b!enc.(pk b, nonce.nb)
    ->  SKIP

Responder(self: USR) = |~| a: USR @ |~| na: NONCE @
        recv!self!a!enc.(pk self, sq.(cons.(nonce.na, cons.(user.a, nil.()))))
    ->  running!self!a!na
    ->  |~| nb: NONCE @ (nb != na) & 
        send!self!a!enc.(pk a, sq.(cons.(nonce.na, cons.(nonce.nb, nil.()))))
    ->  recv!self!a!enc.(pk self, nonce.nb)
    ->  commit!self!a!nb
    ->  SKIP

Participant(u:USR) = Initiator(u) |~| Responder(u)

Network = send?from?to?m -> recv!to!from!m -> Network

Impl = let ua = a.() within
       let ub = b.() within
        (Participant(ua) [| {} |] Participant(ub)) 
        [| {send.*{USR.USR.MSG}, recv.*{USR.USR.MSG}} |] Network

assert {} |- Impl : Proc(T)

---------------------
-- Add an Intruder --
---------------------

datatype L_MSG = \L -> nil.() | cons.MSG.L
datatype FACT = L_MSG.MSG
datatype L_FACT = \L1 -> nil.() | cons.FACT.L1 


--------------------
-- List Functions --
--------------------

datatype Maybe_FACT = nothing.() | just.FACT

remElement_L_FACT = \rem: FACT -> \xs: (nil.() | cons.FACT.L_FACT) ->
    case xs
        of nil -> \y: () -> nil.()
        of cons -> \tpl: FACT.L_FACT -> 
            let a = (pr 1 tpl) :: FACT within
            let li = (pr 2 tpl) :: L_FACT within
            if a == rem then li else cons.(a, li); 

safeHead_L_FACT = \xs: nil.() | cons.FACT.Maybe_FACT ->
    case xs 
        of nil -> \y: () -> nothig.()
        of cons -> \tpl: FACT.Maybe_FACT -> just.(pr 1 tpl);

rec union_L_FACT :: L_FACT -> (L_FACT -> L_FACT) = \xs: L_FACT -> \ys: L_FACT ->
    case fold xs safeHead_L_FACT
        of just -> \y: MSG -> (union (fold xs (remElement_L_FACT y))) (cons.(y, ys))
        of nothig -> \y: () -> ys;

empty_L_FACT = nil.() :: L_FACT;

---------

datatype Maybe_MSG = nothing.() | just.MSG
datatype Maybe_L_MSG = nothing.() | just.L_MSG

remElement_L_MSG = \rem: MSG -> \xs: (nil.() | cons.MSG.L_MSG) ->
    case xs
        of nil -> \y: () -> nil.()
        of cons -> \tpl: MSG.L_MSG -> 
            let a = (pr 1 tpl) :: MSG within
            let li = (pr 2 tpl) :: L_MSG within
            if a == rem then li else cons.(a, li); 

safeHead_L_MSG = \xs: nil.() | cons.MSG.Maybe_MSG ->
    case xs 
        of nil -> \y: () -> nothig.()
        of cons -> \tpl: MSG.Maybe_MSG -> just.(pr 1 tpl);

datatype Maybe_TPL_MSG_L_MSG = nothig.() | just.(MSG.L_MSG)

tail_L_MSG = (\ys: L_MSG -> case (fold ys tailReducer_L_MSG) :: Maybe_TPL_MSG_L_MSG
    of just -> \tpl: MSG.L_MSG -> just.(pr 2 tpl)
    of _ -> nothig.()) :: L_MSG -> Maybe_L_MSG;

tailReducer_L_MSG = \xs: nil.() | cons.MSG.Maybe_TPL_MSG_L_MSG -> 
    case xs 
        of cons -> \y : MSG.Maybe_TPL_MSG_L_MSG ->
            let m = pr 1 y within
            let maybe_tpl = pr 2 y within
            case maybe_tpl
                of nothig -> \n : () -> just.(m, nil.())
                of just -> \tpl : MSG.L_MSG ->  
                    let prev_m = pr 1 tpl within
                    let ls = pr 2 tpl within
                    let ls_new = cons.(prev_m, ls) :: L_MSG within
                        just.(m, ls_new)
        of _ -> nothig.();


rec union_L_MSG :: L_MSG -> (L_MSG -> L_MSG) = \xs: L_MSG -> \ys: L_MSG ->
    case fold xs safeHead_L_MSG 
        of just -> \y: MSG -> (union_L_MSG (fold xs (remElement_L_MSG y))) (cons.(y, ys))
        of nothig -> \y: () -> ys;


rec app_L_MSG :: L_MSG -> (L_MSG -> L_MSG) = \xs: L_MSG -> \ys: L_MSG ->
    case fold xs safeHead_L_MSG 
        of just -> \y: MSG -> 
            let maybe_tl = tail_L_MSG xs within
            case maybe_tl
                of just -> \tl : L_MSG -> (app_L_MSG tl) (cons.(y, ys))
                of _ -> cons.(y, ys)
        of nothig -> \y: () -> ys;

empty_L_MSG = nil.() :: L_MSG;

------------------------
-- End List Functions --
------------------------

asMsgList = \m : MSG -> (cons.(m, nil.())) :: L_MSG;   

-- Reduce an msg := sq.[m1, ..., mn] to [(msg, mj) | j<-1..n]
-- MSG -> [MSG] -> MSG -> L_FACT
sqReducer = \outerMessage: MSG -> \xs : nil.() | cons.MSG.L_FACTS ->
    case xs of nil.() -> \y: () -> nil.()
            of cons -> \tpl : MSG.L_FACTS ->
                let m = pr 1 tpl within 
                let l = pr 2 tpl within
                cons.((asMsgList outerMessage, m), l);

-- MSG -> L_FACT
msgReducer = \xs : \M -> nonce.NONCE | key.KEY | enc.KEY.M | user.USR | sq.(\L -> nil.() | cons.MSG.L)

duduce = \xs : nil.() | cons.MSG.L_FACT -> 
    case xs of nil -> \y : () -> nil.()
            of cons -> \tpl : MSG.L_FACT ->
                let m = pr 1 tpl within 
                let l = pr 2 tpl within
                case m
                    of sq -> 
                        \y: L_MSG -> let newFacts = fold y (sqReducer m) within cons.(newFacts, l)
                    of enc ->
                        \y: KEY.MSG -> 


isSq = \xs : nonce.NONCE | key.KEY | enc.KEY.Bool | user.USR | sq.(\L_isSq -> nil.() | cons.Bool.L_isSq) ->
    case xs
        of sq : \y: (\L_isSq_case -> nil.() | cons.Bool.\L_isSq_case) -> True
        of _ -> False;

filterSqMsgs = \xs : nil.() | cons.MSG.L_MSG -> 
    case xs 
        of nil : \y : () -> nil.()
        of cons : \tpl : MSG.L_MSG ->
            let m = pr 1 tpl within 
            let l = pr 2 tpl within
                if (fold m isSq) then cons.(m, l) else l;


appReduce_L_L_MSG = \xs : cons.L_MSG.L_MSG | nil.() ->
    case xs 
        of cons -> \tpl : L_MSG.L_MSG -> 
            let acc = pr 2 tpl within
            let ls = pr 1 tpl within
            app_L_MSG ls acc
        of _ -> nil.();
            

-- assumes that the messages top level constructor is sq (e.g. by use of isSq)
getSqBody = \xs : nonce.NONCE | key.KEY | enc.KEY.L_MSG | user.USR | sq.(\L_getSqBody -> nil.() | cons.L_MSG.L_getSqBody) ->
    case xs
        of nonce -> \y : NONCE -> (asMsgList nonce.y)
        of key -> \y : KEY -> (asMsgList key.y)
        of enc -> \y : KEY.L_MSG -> 
            let k = pr 1 y within
            let lmsg = pr 2 y within 
            let el = fold lmsg safeHead_L_MSG within
            case el 
                of just -> \y : MSG -> (asMsgList (enc.(k, y)))
                of _ -> nil.()
        of user -> \y : USR -> (asMsgList user.y)
        of sq -> \y : (\L_getSqBody_case -> nil.() | cons.L_MSG.L_getSqBody_case) -> (fold y appReduce_L_L_MSG) :: L_MSG

mapSqReducerUnionReduce_L_MSG = \xs : nil.() | cons.MSG.L_FACT -> 
    case xs
        of cons -> \tpl : MSG.L_FACT -> 
            let msg = pr 1 tpl within
            let ls = pr 2 tpl within 
            let body = (fold msg getSqBody) :: L_MSG within
            let facts = (fold body (sqReducer msg) ) :: L_FACT within
            union_L_FACT facts ls
    case _ -> nil.();

mapReassembleSqFromBody_L_MSG = \xs : nil.() | cons.MSG.L_FACT ->
    case xs
        of cons -> \tpl : MSG.L_FACT -> 
            let msg = pr 1 tpl within
            let ls = pr 2 tpl within 
            let body = (fold msg getSqBody) :: L_MSG within
            let fact = cons.((body, msg), nil.()) :: L_FACT within
            union_L_FACT fact ls
        of _ -> nil.();

-- Assemble and Dissasemble Sq Messages
deductions1 = \xs: L_MSG ->
    let list_sqs = (fold xs filterSqMsgs) :: L_MSG within 
    let deconstructSqFacts = fold list_sqs mapSqReducerUnionReduce_L_MSG within
    let constructionFact = fold list_sqs mapReassembleSqFromBody within
    union_L_FACT constructionFact deconstructSqFacts;

datatype TPL_L_FACT_MSG = L_FACT.MSG 

caseSplitEnc = \m : nonce.NONCE | key.KEY | enc.KEY.TPL_L_FACT_MSG | user.USR | sq.(\L_caseSplitEnc -> nil.() | cons.TPL_L_FACT_MSG.L_caseSplitEnc) ->
    case m
        of nonce -> \y : NONCE -> (nil.(), nonce.y)
        of key -> \y : KEY -> (nil.(), key.y)
        of user -> \y : USR -> (nil.(), user.USR)
        of enc -> \tpl : KEY.TPL_L_FACT_MSG -> 
            let k = pr 1 tpl within
            let ftpl = pr 2 tpl within
            let msg = pr 2 ftpl within
            let encrypt = (cons.(k, cons.(msg, nil.())), enc.(k, msg)) within
            let decrypt = (cons.(enc.(k, msg), cons.(dual k, nil.())), msg) within
            (cons.(encrypt, cons.(decrypt, nil.())), enc.tpl)
        of sq -> \ls : \L_caseSplitEnc_case -> nil.() | cons.TPL_L_FACT_MSG.L_caseSplitEnc_case -> (nil.(), fold ls sndPick);

sndPick = \xs: nil.() | cons.TPL_L_FACT_MSG.L_MSG ->
    case xs 
        of cons -> \tpl : TPL_L_FACT_MSG.L_MSG ->
            let mtpl = pr 1 tpl within
            let m = pr 2 mtpl within
            let ls = pr 2 tpl within
            cons.(m, ls)
        _ -> nil.();

mapUnionFactsFromEnc = \xs: nil.() | cons.MSG.L_FACT -> 
    case xs
        of cons -> \tpl : MSG.L_FACT ->
            let m = pr 1 tpl within
            let ls = pr 2 tpl within 
            let factsFromMsg = (fold m caseSplitEnc) :: L_FACT within
            let fs = pr 1 factsFromMsg within union_L_FACT fs ls
        of _ -> empty_L_FACT;

-- Encrypt and Decrypt Messages
deductions2 = \xs: L_MSG -> (fold xs mapUnionFactsFromEnc) :: L_FACT;

deductions = \xs: L_MSG -> 
    let d1 = deductions1 xs within
    let d2 = deductions2 xs within
    union_L_FACT d1 d2;

datatype TPL_L_MSG_MSG = L_MSG.MSG
datatype TPL_L_MSG_L_MSG = L_MSG.L_MSG

-- fold helper: Accumulates the sub explode sets and the original sq message sequence
unionSnd = \ls : nil.() | cons.TPL_L_MSG_MSG.TPL_L_MSG_L_MSG ->
    case ls
        of cons -> \ttpl : TPL_L_MSG_MSG.TPL_L_MSG_L_MSG ->
            let tpl = pr 1 ttpl within
            let accTpl = pr 2 ttpl within -- accumulator tuple for this fold
            let msg = pr 2 tpl within
            let explodeAcc = pr 1 tpl within -- accumulator produced by explode
            let sqls = pr 2 accTpl within 
            let acc = pr 1 accTpl within -- acummulator list
            let rsqls = cons.(msg, sqls) within -- collect the message reconstructing the original sq
            let racc = union_L_MSG acc explodeAcc within
            (racc, rsqls)
        of _ -> (nil.(), nil.());

-- Separate a MSG into Facts (All Submessages)
explode = \m : m : nonce.NONCE | key.KEY | enc.KEY.TPL_L_MSG_MSG | user.USR | sq.(\L_explode -> nil.() | cons.TPL_L_MSG_MSG.L_explode)
    case m
        of nonce -> \y: NONCE -> (asMsgList nonce.y, nonce.y)
        of key   -> \y: KEY   -> (asMsgList key.y, key.y)
        of user  -> \y: USR   -> (asMsgList user.y, user.y)
        of enc   -> \tpl: KEY.TPL_L_MSG_MSG ->
            let k = pr 1 tpl within
            let ltpl = pr 2 tpl within
            let ls = pr 1 ltpl within
            let msg = pr 2 ltpl within 
            let es = cons.(key.k, cons.(enc.msg, ls)) within (es, enc.msg)
        of sq    -> \ys:  \L_explode_case -> nil.() | cons.TPL_L_MSG_MSG.L_explode_case ->
            let reconstrTpl = (fold ys unionSnd) :: TPL_L_MSG_MSG within
            let acc = pr 1 reconstrTpl within
            let ms = pr 2 reconstrTpl within
            (acc, sq.ms);

-- fold over Messages 

-- Ideen um {m <- messages} zu umgehen

-- Process offers deductions. Spy has knowledge. if the deduction can be obtained from the
-- knowledge, then the Spy may perform the action

-- Orcale function yielding the useful deductions "magically"
