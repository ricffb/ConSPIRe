datatype Alpha = \A -> a.() | sq.(\Li -> nil.() | cons.A.Li)
datatype T = out.L_Alpha
datatype L_Alpha = \L -> nil.() | cons.Alpha.L
datatype Beta = b.() | none.()
datatype Maybe_Alpha = just.Alpha | none.()


e1 = (cons.(a.(), cons.(sq.(cons.(a.(), nil.())), nil.()))) :: L_Alpha;

remElement = \rem: Alpha -> \xs: (nil.() | cons.Alpha.L_Alpha) ->
    case xs
        of nil -> \y: () -> nil.()
        of cons -> \tpl: Alpha.L_Alpha -> 
            let a = (pr 1 tpl) :: Alpha within
            let li = (pr 2 tpl) :: L_Alpha within
            if a == rem then li else cons.(a, li); 

getElement = \xs: nil.() | cons.Alpha.Maybe_Alpha ->
    case xs 
        of nil -> \y: () -> none.()
        of cons -> \tpl: Alpha.Maybe_Alpha -> just.(pr 1 tpl);

    

-- [A] -> [A] -> [A] 
rec app :: L_Alpha -> (L_Alpha -> L_Alpha) = \xs: L_Alpha -> \ys: L_Alpha ->
    case fold xs getElement 
        of just -> \y: Alpha -> (app (fold xs (remElement y))) (cons.(y, ys))
        of none -> \y: () -> ys;


unseq = \xs: nil.() | cons.Alpha.L_Alpha ->
    case xs 
        of nil -> \y: () -> nil.()
        of cons -> \tpl : Alpha.L_Alpha ->
            let alph = pr 1 tpl within 
            let li = pr 2 tpl within
            fold alph (caseSplitAlpha li);

caseSplitAlpha = \li: L_Alpha -> \xs: a.() | sq.(\Li -> nil.() | cons.L_Alpha.Li) ->
    case xs
        of a -> \y: () -> cons.(a.(), li)
        of sq -> \s: (\Li1 -> nil.() | cons.L_Alpha.Li1) -> fold s caseSplitSq; 

caseSplitSq = \xs: nil.() | cons.L_Alpha.L_Alpha ->
    case xs
        of nil -> \y: () -> nil.()
        of cons -> \tpl: L_Alpha.L_Alpha -> 
            let l1 = pr 1 tpl within
            let l2 = pr 2 tpl within
            app l1 l2; -- (pr 2 tpl); --

datatype L_L_Alpha = \LL -> nil.() | cons.L_Alpha.LL
-- Alpha -> L_Alpha -> L_Alpha
consLA = \y: L_Alpha -> \ys: L_L_Alpha -> cons.(y, ys);

listlistAlpha = ((consLA e2) ((consLA nil.()) nil.())) :: L_L_Alpha;
e2 = cons.(a.(), nil.()) :: L_Alpha;

e3 = (cons.(a.(), e2)); --:: nil.() | cons.Alpha.L_Alpha ;

datatype T2 = out.((a.() | sq.(\Li2 -> nil.() | cons.L_Alpha.Li2)) -> L_Alpha)

Pr = out!(caseSplitAlpha e2) -> STOP

assert  {} |- Pr : Proc( T2 )


Test = out!(fold e1 unseq) -> STOP

assert  {} |- Test : Proc( T )
